# TFC CTF 2024

第一次参加 CTF 比赛，感觉比赛的训练效果属实不错。一共做了 8 题，755 分，排名 104 / 1471。很可惜，比赛 7 点结束，有一道逆向题 7 点 01 分才拿到 flag，没能赶上提交，要不然能进前一百的 :cry: 

<div align="center">
    <img src=".\pic\01.png" alt="" height="250">
    <img src=".\pic\02.png" alt="" height="250">
</div>

顺带一提，题目包含的一些文件在 [这里](./file)，文件夹名称就是题目名称



## MISC

### Rules

<div align="center">
    <img src=".\pic\misc01.png" alt="" width="600">
</div>

签到题，看一下规则就可以了

<div align="center">
    <img src=".\pic\misc02.png" alt="" width="600">
</div>

`TFCCTF{M4ny_ch4ng3s...m0r3_3ff0rt}` 

### Discord Shinanigans V4

<div align="center">
    <img src=".\pic\misc03.png" alt="" width="600">
</div>

题目要求去 Discord 上的 TFC CTF 社区的 #bot-commands 分区找 flag

<div align="center">
    <img src=".\pic\misc04.png" alt="" width="600">
</div>

发现 bot 在重复说几句话，一开始还以为是什么隐写，把这 5 句话放到一起看了看，什么都没看出来

后面直接复制其中的一句话 (对着这句话右键 —> 复制文字)，粘贴到超文本编辑器上 (直接粘 VSCode 上就行)，会看到以下文字，大概是用不可打印字符隐藏了消息

`It's not here... Oh wait, it actually is |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| _ _ _ _ _ _  add this to the format: zoo_wee_mama`

最后得到 flag: `TFCCTF{zoo_wee_mama}`

### Secret Message

<div align="center">
    <img src=".\pic\misc05.png" alt="" width="600">
</div>

打开给出 `main.py`，发现是让我们给定 6 个不同的数字作为种子，然后调用加密函数 `hide(string, seed, shuffle)` 进行加密，如果 6 次加密后的结果和没有加密前一致，就能获得 flag

```python
def hide(string, seed, shuffle):
    random.seed(seed)
    byts = []
    for _ in range(len(string)):
        byts.append(random.randint(0, 255))
    random.seed(shuffle)
    for i in range(100):
        random.shuffle(byts)
    return bytes([a^b for a, b in zip(string, byts)])
```

观察函数，其中 6 次加密用的 `shuffle` 是同一个，并且是个随机数。虽然没完全弄懂原理，但是猜出来如果用 `x` 加密一次，再用 `-x` 加密一次，消息会不被加密。

连接容器，输入 6 个种子：1 -1 2 -2 3 -3，然后拿到 flag: `TFCCTF{random_is_not_secur3}` 



## Crypto

### CCCCC

<div align="center">
    <img src=".\pic\cryp01.png" alt="" width="600">
</div>

签到题。打开 `ccccc.txt` 发现一串文字

`5c4c4c6c4c3c4c3c5c4c4c6c7cbc6c3c7c3c6c8c6cfc7c5c7c4c5cfc6c3c6cfc7c5c7c4c5cfc6c3c7c4c3c0c5cfc6c3c6cdc7c9c5cfc6c3c6c2c3c0c7c9c5cfc6c3c3c4c6cec6c4c5cfc6c3c6cdc7c9c5cfc6c3c6c4c6cfc6c7c5cfc6c3c6c1c6cec6c4c5cfc6c3c6cdc7c9c5cfc6c3c6c3c3c4c3c7c7cdc0ca`

观察特点发现，每个 16 进制字符后都有一个 `c`，结合题目叫 CCCCC，尝试去掉这些 `c`，得到一个 16 进制字符串，再按 ASCII 码转字符串，得到 flag: `TFCCTF{cshout_cout_ct0_cmy_cb0y_c4nd_cmy_cdog_cand_cmy_cc47}` 

解密代码如下

```python
flag = '5c4c4c6c4c3c4c3c5c4c4c6c7cbc6c3c7c3c6c8c6cfc7c5c7c4c5cfc6c3c6cfc7c5c7c4c5cfc6c3c7c4c3c0c5cfc6c3c6cdc7c9c5cfc6c3c6c2c3c0c7c9c5cfc6c3c3c4c6cec6c4c5cfc6c3c6cdc7c9c5cfc6c3c6c4c6cfc6c7c5cfc6c3c6c1c6cec6c4c5cfc6c3c6cdc7c9c5cfc6c3c6c3c3c4c3c7c7cdc0ca'
flag = flag.replace('c', '')
flag = ''.join(chr(int(flag[i:i+2], 16)) for i in range(0, len(flag), 2))
print(flag)
```

### Genetics

<div align="center">
    <img src=".\pic\cryp02.png" alt="" width="600">
</div>

另一道签到题。这是碱基加密，A T C G 分别对应 00 01 10 11，4 个字母也就是 8 bit 刚好对应 ASCII 码的一个字符，但是具体哪个字母对应哪个需要尝试。以下是解题代码：

```python
s = 'CCCA CACG CAAT CAAT CCCA CACG CTGT ATAC CCTT CTCT ATAC CGTA CGTA CCTT CGCT ATAT CTCA CCTT CTCA CGGA ATAC CTAT CCTT ATCA CTAT CCTT ATCA CCTT CTCA ATCA CTCA CTCA ATAA ATAA CCTT CCCG ATAT CTAG CTGC CCTT CTAT ATAA ATAA CGTG CTTC'
flag = ''
for i in range(len(s)):
    if s[i] == 'C':
        flag += '01'
    elif s[i] == 'A':
        flag += '00'
    elif s[i] == 'T':
        flag += '11'
    elif s[i] == 'G':
        flag += '10'
    else:
        flag += s[i]

flag = flag.replace(" ", "")
res = ""
for i in range(0, len(flag), 8):
    char = flag[i:i+8]
    decimal_value = int(char, 2)
    res += chr(decimal_value)
print(res)
```

最后得到 flag: `TFCCTF{1_w1ll_g3t_th1s_4s_4_t4tt00_V3ry_s00n}`

### Conway

<div align="center">
    <img src=".\pic\cryp03.png" alt="" width="600">
</div>

拿到两个文件，`main.py` 是加密代码，`output.txt` 是输出的结果

先看看 `main.py`，`initial` 是一个只包含 1 2 3 的数字串，经过 `generate_next_key(initial)` 这个函数加密过后，再进行输出，这是本题的第一部分

```python
initial = 11131221131211131231121113112221121321132132211331222113112211
initial = generate_next_key(initial)
print(initial)   # 311311222113111231131112132112311321322112111312211312111322212311322113212221
```

观察发现，这个函数对数列的外观进行了一个描述，然后得到加密后的数字串。例如，111221 会被描述为，3 个 1，2 个 2，1 个 1，加密后就变为 312211。根据此规律即可还原 `generate_next_key(initial)`，也可以参照 Leetcode 上的题目 [外观数列](https://leetcode.cn/problems/count-and-say/description/)，还原的函数如下：

```python
def generate_next_key(prev):
    prev = str(prev)
    curr = ""
    start = 0
    pos = 0
    while pos < len(prev):
        while pos < len(prev) and prev[pos] == prev[start]:
            pos += 1
        curr += str(pos - start) + prev[start]
        start = pos
    return curr
```

```python
initial = generate_next_key(initial)
h = hashlib.sha256()
h.update(str(initial).encode())
key = h.digest()

cipher = AES.new(key, AES.MODE_ECB)
print(cipher.encrypt(pad(flag.encode(), 16)).hex())
# f143845f3c4d9ad024ac8f76592352127651ff4d8c35e48ca9337422a0d7f20ec0c2baf530695c150efff20bbc17ca4c
```

随后又对 `initial` 进行了一次 `generate_next_key(initial)` 函数的加密，又使用 SHA256 哈希得到 `key`，最后使用 AES 对称加密的 ECB 模式以 `key` 为密钥加密了 `flag` 

先还原好 `generate_next_key(initial)` 函数，然后运行并打印 `key`，得到 `609fd95c2155dfc76de2212c06b09f4ffa3b911d023b871f45a4eab530b393f3` 

再使用 [AES 解密网站](https://the-x.cn/cryptography/Aes.aspx) 解密 (也可以用 python 解密，需要一些特定的外部库)，能够解出 flag: `TFCCTF{c0nway's_g4me_0f_sequences?}`

### Rotator Cuffs

<div align="center">
    <img src=".\pic\cryp04.png" alt="" width="600">
</div>

Medium 难度，总共 38 解，应该是我做出来的最难的题了。给的材料有 `main.sage` 是加密代码 (sage 直接当 python 就行)，`output.txt` 是运行 `main.sage` 时的输出。

```python
sumyum = -142226769181911294109604985414279966698269380324397182385943224688881786967396493297107323123238846393606215646973028804858833605857511769169835160302020010947120438688346678912969985151307036771093126928042899151991372646137181873186360733201445140152322209451057973604096364822332301687504248777277418181289153882723092865473163310211285730079965167100462695990655758205214602292622245102893445811728006653275203674798325843446182682402905466862314043187136542260285271179956030761086907321077282094937573562503816663264662117783270594824413962461600402415572179393223815743833171899844403295401923754406401502029098878225426758204788
assert sumyum == 2 * x1 ** 2 - SECRET * y1 ** 2 + 2 * x2 ** 2 - SECRET * y2 ** 2
```

先看 `main.sage`，定义了一个很大的整数 `sumyum`，然后限制了几个变量之间的关系
$$
2(x_1^2+x_2^2)-\text{SECRET}(y_1^2+y_2^2)=\text{sumyum}
$$

```python
F = RealField(3456)
x = vector(F, [x1, x2])
y = vector(F, [y1, y2])

for _ in range(10000):
    theta = F.random_element(min=-5 * pi, max=5 * pi)
    R = matrix(F, [[cos(theta), -sin(theta)], [sin(theta), cos(theta)]])
    x = R * x
    y = R * y

print("resulting_x =", x)
print("resulting_y =", y)
```

然后把对 `x = (x1, x2)` 和 `y = (y1, y2)` 这两个点进行了 10000 次旋转，每次随机旋转 $[-5\pi,5\pi]$，最后输出两点的坐标。对上面的式子进行观察可以发现，$x_1^2+x_2^2$ 就是点 $x$ 的模长，因此旋转并不会造成影响，化简上式有
$$
\text{SECRET}=\frac{2\|x\|^2-\text{sumyum}}{\|y\|^2}
$$
根据最后打印出来的点坐标，可以计算模长，进而可以计算出 SECRET，解题代码如下：

```python
import mpmath

mpmath.mp.dps = 10000000
x1 = mpmath.mpf('3.3634809129087361339072596725006530600959848462815297766832600914180365498172745779530909095267862889993244875375870115862675521807203899602656875152466204714275847395081849947663071267678766620524700684572851632968584152642766533856599351512856580709762480161587856072790441655306539706390277559619708164477066112096159734609814163507781608041425939822535707080207842507025990454423454350866271037975269822168384397403714076341093853588894719723841956801405249658560486108807190027518922407932998209533025998785987344569930974892824749931597842343369782141668038797305601028366704322107431479213165353278773002704707347001056980736352878716736155054293350509670339144379602697176068785416128203382284653052813910539052285224499161723972390574800570738938264516350981139157860135237512937090793549860152173756751719627025142858529263243314917653507237003568510016357713402278753999645732592631577726849749929789275649985363293274521704758513276997442425705172979362522303209937874019044195572717894784790824040985970678829869212168596332338e228')
x2 = mpmath.mpf('4.3493076236586169242233212405270398931813271488805260703904730395387317512159124699671617536806847379014763743850012966440449858042327139796085868934120939346500622666309663813415016921760622643752056516232426324399548704613192843351795229042500735885925583510203795565452553753954474949980588780332651769544235511465216034600990329267883327087177217125655503845919331440817328958054102807738186874040636118222352351053320953917165679774298608790659071127811941909136888169274293065733698380573486079052876249484455409206182001827225690775874445171478338344209529207109172368590360722150559332665968826925103060717742483611155201852629766859356827518117986215929527812137774656124580645282319815982553388185475874607903050755710964732279490338614504903256117014312989278124177060468718045944298976827788272885547066724342578660563396148909159051946415261351324693896674313199869788279492452177771905587881622085592044441472137286330359635594402564357596784568377870545793505212074411425362120275312322293627143588322908897500139505746513232e228')
y1 = mpmath.mpf('3.0086123485184949854819528432444522887263618452152977201477700454454717599185922285792607291484161348863603668674724666302028473336653202339259214779198337146709052083562504123644969759313504022148939497579033947489964578987257010705347661159352495880621564046451129149321751369899157697461990748527068553919767557375414807745137776378672423131583632676118768803623661016450513713378889178790819115525404124475586398119768281556573742250499881136366816528002891506377591473809774876327335425713426558761290418087432306668623923825516541279687269109753438014462223886767964900168026643719447209474190574704192551865457553267219179816090151816092471203713238427208397671093453024024773606469951052196613699816481289760243547361942029869165939022611782658000517871759272476768999453412473058498224382162775678590320117678687959374599497850317809926761224934950410879753727042047871292717229649696383856159211062622325024918849176324424823611459590717866478574927162324917352318674258311617781845396479605897293293787546058229588461669469113001e228')
y2 = mpmath.mpf('4.1955438730064492244518395125687091233417321001179084616477593364143186962035096742717340249485256810878365124925979444527539802357032735868877910266504910589105346718553503670072791148806000734099122372428956062737130602189826489676949800396857262364104813055382317498461363421406914514918460816121876800728600531432610837129788010503804927836206596876591613685011706833895602299866191433190745884295362337967940063679204541643670409168084686978205876941245671248753306754892761206974604980311577415661960800437927228624982030061751022139301406066860249918396002252864930009083759551916555623475795108943840654272107400479044754688171126386094896825019962082090350188892677712358612478027143147182776057102433244569971150928964257290752485837202929975257858813456753394801152212850446322739077604336730800210171231609831225616780923301071587159265696870229784689201181607735865814975046649574472138172333744474559659785291954987787639082881571990180182337133038177924408020273887276582566592470019342076814034084107444178243083855840959209e228')
sumyum = mpmath.mpf('-142226769181911294109604985414279966698269380324397182385943224688881786967396493297107323123238846393606215646973028804858833605857511769169835160302020010947120438688346678912969985151307036771093126928042899151991372646137181873186360733201445140152322209451057973604096364822332301687504248777277418181289153882723092865473163310211285730079965167100462695990655758205214602292622245102893445811728006653275203674798325843446182682402905466862314043187136542260285271179956030761086907321077282094937573562503816663264662117783270594824413962461600402415572179393223815743833171899844403295401923754406401502029098878225426758204788')

flag = (2 * (x1 * x1 + x2 * x2) - sumyum) / (y1 * y1 + y2 * y2)
flag = int(flag)
hex_flag = hex(flag)[2:]
str_flag = ''
for i in range(0, len(hex_flag), 2):
    ascii_character = chr(int(hex_flag[i:i+2], 16))
    str_flag += ascii_character
print(str_flag)
```

这里用了 `mpmath` 包进行高精度计算，当然可以用别的替代，甚至直接用 `sage` 就行

最后得到 flag: `TFCCTF{r0t4t3_and__g0_furth3r...s4me_th1ng...schr0d1ng3r's_r0tat1on...not}`



## Reverse

本来不会逆向，是比赛第二天的下午赶紧现学的，做了两道简单题，最后一道还没来得及提交 :crying_cat_face: 

### Signal

<div align="center">
    <img src=".\pic\rev01.png" alt="" width="600">
</div>

给出了一个文件 `signal`，用命令 `$ file signal` 查看发现是 elf 文件，直接扔进 IDA 进行逆向

<div align="center">
    <img src=".\pic\rev02.png" alt="" width="600">
</div>

发现有 6 个函数，其功能是对用户输入的内容逐个字符进行 ASCII 码对比，一旦不一致，就输出 `Nope` 然后退出。题目提示 flag 是 32 bytes，而这里 6 个函数总共对比也是 32 个字符，因此这很可能就是 flag 的 ASCII 码，转换后得到 flag: `TFCCTF{b11e807f65b27dcf82e70c4bad63a3eb}` 

### License

<div align="center">
    <img src=".\pic\rev03.png" alt="" width="600">
</div>

给出了一个文件 `license`，发现是 elf 文件，直接扔进 IDA 进行逆向。逆向后查看主函数：

```c++
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  puts("Please enter your license key to use this program!");
  fgets(src, 18, stdin);
  if ( strlen(src) != 17 )
    exit(0);
  if ( src[16] == 10 )
    src[16] = 0;
  strncpy(dest, src, 8uLL);
  byte_4088 = 0;
  if ( (unsigned int)sub_1209(dest) == 1 )
  {
    puts("Nope");
    exit(0);
  }
  // other code
}
```

大致是读取了长度为 17 的字符串，然后将前 8 个字符复制一遍，然后调用函数 `sub_1209(string)` 进行判断并期望返回 0

```c++
if ( byte_4068 != 45 )
  exit(0);
```

然后判断第 9 个字符的 ASCII 值是否为 45，即 `-`

```c++
if ( byte_4068 != 45 )
  exit(0);
strncpy(byte_4090, byte_4069, 8uLL);
if ( (unsigned int)sub_1345(byte_4090) == 1 )
{
  puts("Nope");
  exit(0);
}
puts("Congrats! Get the flag on remote.");
return 0LL;
```

然后复制了后 8 个字符，调用 `sub_1345(string)` 进行判断并期望返回 0，如果所有判断都成功了，说明输入的 17 位字符串有效，就可以拿到 flag

```c++
__int64 __fastcall sub_1209(__int64 a1)
{
  int v1; // eax
  int i; // [rsp+18h] [rbp-18h]
  int j; // [rsp+1Ch] [rbp-14h]
  char v5[8]; // [rsp+20h] [rbp-10h]
  unsigned __int64 v6; // [rsp+28h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  for ( i = 0; i <= 7; ++i )
  {
    v1 = i % 3;
    if ( i % 3 == 2 )
    {
      v5[i] = *(_BYTE *)(i + a1) - 37;
    }
    else if ( v1 <= 2 )
    {
      if ( v1 )
      {
        if ( v1 == 1 )
          v5[i] = *(_BYTE *)(i + a1) + 16;
      }
      else
      {
        v5[i] = *(_BYTE *)(i + a1) ^ 0x5A;
      }
    }
    v5[i] ^= 0x33u;
  }
  for ( j = 0; j <= 7; ++j )
  {
    if ( (unsigned __int8)v5[j] != aXsl3bdxp[j] )
      return 1LL;
  }
  return 0LL;
}
```

先查看函数 `sub_1209(string)`，对输入的长度为 8 的字符串进行一些操作，最后跟标准做对比，对比成功则返回 0. 可以看到变量 `aXsl3bdxp` 是一个长度为 8 的字符串 `'Xsl3BDxP'`，将对字符串的操作进行化简：

```c++
for ( i = 0; i <= 7; ++i )
{
  if ( i % 3 == 2 ) v5[i] = *(_BYTE *)(i + a1) - 37;
  else if ( i % 3 == 1 ) v5[i] = *(_BYTE *)(i + a1) + 16;
  else v5[i] = *(_BYTE *)(i + a1) ^ 0x5A;
  v5[i] ^= 0x33u;
}
```

既然已知最终结果和操作过程，即可还原字符串，为 `'10\x84Za\x9c\x11S'` ，这里面有不可打印字符，要注意

```c++
__int64 __fastcall sub_1345(__int64 a1)
{
  int i; // [rsp+18h] [rbp-8h]
  int j; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i <= 7; ++i )
  {
    if ( ((*__ctype_b_loc())[*(char *)(i + a1)] & 0x200) != 0 )
    {
      *(_BYTE *)(i + a1) = (*(char *)(i + a1) - 92) % 26 + 97;
    }
    else if ( ((*__ctype_b_loc())[*(char *)(i + a1)] & 0x100) != 0 )
    {
      *(_BYTE *)(i + a1) = (*(char *)(i + a1) - 48) % 26 + 65;
    }
  }
  for ( j = 0; j <= 7; ++j )
  {
    if ( *(_BYTE *)(j + a1) != aMzxaplzr[j] )
      return 1LL;
  }
  return 0LL;
}
```

再看到函数 `sub_1345(string)` ，如果是小写字母 (由 & 0x200 判断)，则进行 `(chr - 92) % 26 + 97` 操作，如果是大写字母，进行 `(chr - 48) % 26 + 65` 操作，最后和变量 `aMzxaplzr` 也就是 `'mzXaPLzR'` 作比较。根据这个逻辑，即可还原字符串，为 `huGvYUuA` 

最后，把两部分拼接在一起就是拿到 flag 的字符串，`10\x84Za\x9c\x11S-huGvYUuA`

注意到在 linux 终端无法输入不可打印字符，因此用 python 的 pwn 包，对服务器进行连接并输入内容，最后拿到 flag

`TFCCTF{ac1da9096a8ad2fcb839565621bf09e892a470a6a7a0498b6259e09525096b9d}`

(不知道为什么这题是 Warm-up 上题是 Easy，感觉这题难度更大一些)